#!/usr/bin/env bash
# ==============================================================================
#  xcat â€” universal clipboard helper for files, stdin, and directories
# ==============================================================================
#
#  Author:  Blaine Bouvier (@WebWalker3D)
#  License: MIT
#  Repo:    https://github.com/WebWalker3D/Xcat
#
#  Description:
#    xcat is a tiny, dependency-light shell utility that prints the contents of
#    a file, stdin, or all regular files in a directory â€” then copies the result
#    to your system clipboard.  It supports optional line-range selection and
#    automatic installation of clipboard tools (xclip, wl-clipboard, pbcopy,
#    or clip.exe) on most Linux and BSD systems.
#
#  Key Features:
#    â€¢ Copy to clipboard from a file, stdin, or directory (non-recursive)
#    â€¢ Select line ranges via -s/-e or -L START:END
#    â€¢ Automatically detect and install a clipboard backend
#    â€¢ Safely handle stdin with a temporary buffer
#    â€¢ Binary-safe guard: refuses or skips non-text data
#    â€¢ Optional preview, verification, compression, and checksum output
#    â€¢ Tee mode: print and copy simultaneously
#
#  Example Usage:
#    xcat ~/.bashrc                       # copy entire file
#    xcat -L 10:30 app.log                # copy specific lines
#    grep ERROR app.log | xcat            # copy grep output
#    xcat /etc/apache2/sites-available/   # copy all text files in dir
#
#  Exit Codes:
#    0  Success
#    1  Runtime error (missing file, no clipboard backend, etc.)
#    2  Invalid usage (bad options, malformed arguments)
#
#  Dependencies:
#    â€¢ bash (â‰¥ 4.0)
#    â€¢ One of: xclip, wl-copy, pbcopy, clip.exe
#
#  Installation (one-liner):
#    sudo curl -L https://raw.githubusercontent.com/WebWalker3D/Xcat/main/xcat \
#      -o /usr/local/bin/xcat && sudo chmod +x /usr/local/bin/xcat
#
# ==============================================================================

set -euo pipefail

VERSION="1.0.0-dev"

# --- globals / flags --------------------------------------------------------

start_line=""
end_line=""

QUIET=0
VERBOSE=0
PREVIEW=0
VERIFY=0
COMPRESS=0
TEE_MODE=0
LIST_BACKENDS_ONLY=0
VERSION_ONLY=0

BACKEND_OVERRIDE=""
TYPE_FILTER=()

CLIP_CMD=()
CLIP_READ_CMD=()
DETECTED_BACKEND=""

INPUT_KIND=""    # "stdin" | "file" | "dir"
INPUT_SOURCE=""  # path or empty for stdin

LINES_COPIED=""

# --- helpers ---------------------------------------------------------------

have() { command -v "$1" >/dev/null 2>&1; }

detect_pkg_mgr() {
  for pm in apt-get dnf yum pacman zypper brew; do
    if have "$pm"; then echo "$pm"; return 0; fi
  done
  return 1
}

try_install() {
  # $1 = target ("xclip" or "wl-clipboard")
  local target="$1"
  local pm
  if ! pm=$(detect_pkg_mgr); then
    echo "xcat: no supported package manager found to install $target." >&2
    return 1
  fi

  [ "$QUIET" -eq 0 ] && echo "xcat: attempting to install $target using $pm (may require sudo)..." >&2

  case "$pm" in
    apt-get)
      sudo apt-get update -y && sudo apt-get install -y "$target"
      ;;
    dnf)    sudo dnf install -y "$target" ;;
    yum)    sudo yum install -y "$target" ;;
    pacman) sudo pacman -Sy --noconfirm "$target" ;;
    zypper) sudo zypper install -y "$target" ;;
    brew)
      case "$target" in
        xclip) sudo -n true 2>/dev/null || true; brew install xclip ;;
        wl-clipboard) brew install wl-clipboard ;;
        *) brew install "$target" ;;
      esac
      ;;
  esac
}

usage() {
  cat <<'EOF'
Usage: xcat [OPTIONS] [FILE]

Copy file (or stdin) to clipboard. Optionally restrict to a line range.

Options:
  -s START         1-based start line (inclusive)
  -e END           1-based end line (inclusive)
  -L A:B           Shorthand for range; either side may be empty (e.g., :50 or 15:)
  -p, --preview    Preview the final payload to stdout (syntax highlighted if possible)
  -q, --quiet      Suppress non-error messages
  -v, --verbose    Print extra diagnostic information
  -V, --version    Show version and exit
      --verify     Read back from clipboard (if supported) and show a short preview
      --compress   gzip + base64-encode payload before copying
      --tee        Print payload to stdout as well as copy to clipboard
      --backend=NAME
                    Force backend: xclip | wl-copy | pbcopy | clip.exe
      --types=EXTS Limit directory mode to given extensions (comma-separated, e.g. conf,service,txt)
      --list-backends
                    Show available clipboard backends and exit
  -h, --help       Show this help and exit

If FILE is omitted, xcat reads from stdin.

If FILE is a directory, xcat will:
  â€¢ Concatenate all regular *text* files in that directory (non-recursively),
  â€¢ Optionally filter by extension via --types,
  â€¢ Prefix each fileâ€™s content with its full path,
  â€¢ Send the combined output to your clipboard.

Examples:
  xcat file.txt                       # whole file
  xcat -s 10 -e 30 file.txt           # lines 10..30
  xcat -L 15: file.txt                # lines 15..end
  grep ERROR app.log | xcat -L :50    # first 50 lines of piped input
  xcat /etc/apache2/sites-available/  # all text files in that directory

EOF
}

version() {
  echo "xcat ${VERSION}"
}

is_uint() { [[ "$1" =~ ^[0-9]+$ ]]; }

is_text_file() {
  # Returns 0 if the file *looks* like text, non-zero if binary or unreadable.
  local f=$1
  [ -r "$f" ] || return 1
  LC_ALL=C grep -Iq . "$f"
}

normalize_types() {
  local raw=$1
  IFS=',' read -r -a TYPE_FILTER <<<"$raw"
  local i
  for i in "${!TYPE_FILTER[@]}"; do
    local t="${TYPE_FILTER[$i]}"
    t="${t## }"
    t="${t%% }"
    if [[ -n "$t" && "$t" != .* ]]; then
      TYPE_FILTER[$i]=".$t"
    else
      TYPE_FILTER[$i]="$t"
    fi
  done
}

match_types() {
  # Return 0 if no filters or file matches a filter
  local file=$1
  if [ "${#TYPE_FILTER[@]}" -eq 0 ]; then
    return 0
  fi
  local ext
  for ext in "${TYPE_FILTER[@]}"; do
    [ -z "$ext" ] && continue
    if [[ "$file" == *"$ext" ]]; then
      return 0
    fi
  done
  return 1
}

resolve_clip_cmd() {
  CLIP_CMD=()
  CLIP_READ_CMD=()
  DETECTED_BACKEND=""

  local b

  # If user forced a backend, honor it
  if [ -n "$BACKEND_OVERRIDE" ]; then
    b="$BACKEND_OVERRIDE"
    case "$b" in
      xclip)
        if have xclip; then
          CLIP_CMD=(xclip -selection clipboard)
          CLIP_READ_CMD=(xclip -selection clipboard -o)
          DETECTED_BACKEND="xclip"
          return 0
        else
          echo "xcat: requested backend 'xclip' not available." >&2
          return 1
        fi
        ;;
      wl-copy)
        if have wl-copy; then
          CLIP_CMD=(wl-copy)
          CLIP_READ_CMD=(wl-paste)
          DETECTED_BACKEND="wl-copy"
          return 0
        else
          echo "xcat: requested backend 'wl-copy' not available." >&2
          return 1
        fi
        ;;
      pbcopy)
        if have pbcopy; then
          CLIP_CMD=(pbcopy)
          CLIP_READ_CMD=(pbpaste)
          DETECTED_BACKEND="pbcopy"
          return 0
        else
          echo "xcat: requested backend 'pbcopy' not available." >&2
          return 1
        fi
        ;;
      clip.exe)
        if have clip.exe; then
          CLIP_CMD=(clip.exe)
          # No easy generic readback for clip.exe; VERIFY will be disabled.
          CLIP_READ_CMD=()
          DETECTED_BACKEND="clip.exe"
          return 0
        else
          echo "xcat: requested backend 'clip.exe' not available." >&2
          return 1
        fi
        ;;
      *)
        echo "xcat: unknown backend '$b' (valid: xclip, wl-copy, pbcopy, clip.exe)" >&2
        return 1
        ;;
    esac
  fi

  # Autodetect (with install attempts)
  if have xclip; then
    CLIP_CMD=(xclip -selection clipboard)
    CLIP_READ_CMD=(xclip -selection clipboard -o)
    DETECTED_BACKEND="xclip"
    return 0
  fi
  if have wl-copy; then
    CLIP_CMD=(wl-copy)
    CLIP_READ_CMD=(wl-paste)
    DETECTED_BACKEND="wl-copy"
    return 0
  fi
  if have pbcopy; then
    CLIP_CMD=(pbcopy)
    CLIP_READ_CMD=(pbpaste)
    DETECTED_BACKEND="pbcopy"
    return 0
  fi
  if have clip.exe; then
    CLIP_CMD=(clip.exe)
    CLIP_READ_CMD=()
    DETECTED_BACKEND="clip.exe"
    return 0
  fi

  # Try to infer environment and install
  if [ -n "${WAYLAND_DISPLAY-}" ]; then
    if try_install wl-clipboard && have wl-copy; then
      CLIP_CMD=(wl-copy)
      CLIP_READ_CMD=(wl-paste)
      DETECTED_BACKEND="wl-copy"
      return 0
    fi
    if try_install xclip && have xclip; then
      CLIP_CMD=(xclip -selection clipboard)
      CLIP_READ_CMD=(xclip -selection clipboard -o)
      DETECTED_BACKEND="xclip"
      return 0
    fi
  elif [ -n "${DISPLAY-}" ]; then
    if try_install xclip && have xclip; then
      CLIP_CMD=(xclip -selection clipboard)
      CLIP_READ_CMD=(xclip -selection clipboard -o)
      DETECTED_BACKEND="xclip"
      return 0
    fi
    if try_install wl-clipboard && have wl-copy; then
      CLIP_CMD=(wl-copy)
      CLIP_READ_CMD=(wl-paste)
      DETECTED_BACKEND="wl-copy"
      return 0
    fi
  fi

  # macOS attempt (brew)
  if [ "$(uname -s)" = "Darwin" ] && have brew; then
    if have pbcopy; then
      CLIP_CMD=(pbcopy)
      CLIP_READ_CMD=(pbpaste)
      DETECTED_BACKEND="pbcopy"
      return 0
    fi
  fi

  # WSL fallback
  if grep -qi microsoft /proc/version 2>/dev/null; then
    if have clip.exe; then
      CLIP_CMD=(clip.exe)
      CLIP_READ_CMD=()
      DETECTED_BACKEND="clip.exe"
      return 0
    fi
  fi

  return 1
}

list_backends() {
  echo "Available clipboard backends:"
  for b in xclip "wl-copy" pbcopy "clip.exe"; do
    if have "${b%% *}"; then
      printf "  âœ“ %s\n" "$b"
    else
      printf "  âœ— %s\n" "$b"
    fi
  done
  if resolve_clip_cmd; then
    echo
    echo "Active (if used now): $DETECTED_BACKEND"
  else
    echo
    echo "Active: (none â€” no backend currently available)"
  fi
}

dir_to_stream() {
  # Concatenate all regular text files in a directory (non-recursive),
  # prefixing each chunk with its full path.
  local dir="$1"
  local f
  shopt -s nullglob
  local entries=( "$dir"/* )
  shopt -u nullglob

  local files=()
  for f in "${entries[@]}"; do
    [ -f "$f" ] && files+=( "$f" )
  done

  if [ "${#files[@]}" -eq 0 ]; then
    echo "xcat: no regular files in directory: $dir" >&2
    return 1
  fi

  local any_text=0
  for f in "${files[@]}"; do
    if ! match_types "$f"; then
      [ "$VERBOSE" -eq 1 ] && echo "xcat: skipping due to type filter: $f" >&2
      continue
    fi
    if ! is_text_file "$f"; then
      [ "$VERBOSE" -eq 1 ] && echo "xcat: skipping non-text file: $f" >&2
      continue
    fi
    any_text=1
    printf '%s\n' "$f"
    cat -- "$f"
    printf '\n'
  done

  if [ "$any_text" -eq 0 ]; then
    echo "xcat: no text files in directory (after filters): $dir" >&2
    return 1
  fi
}

preview_payload() {
  local file="$1"
  [ "$QUIET" -eq 1 ] && return 0

  echo "â”€â”€â”€â”€ preview â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  if have bat; then
    bat --paging=never "$file"
  elif have batcat; then
    batcat --paging=never "$file"
  else
    cat "$file"
  fi
  echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
}

verify_clipboard() {
  [ "$VERIFY" -eq 1 ] || return 0
  [ "$QUIET" -eq 1 ] && return 0

  if [ "${#CLIP_READ_CMD[@]}" -eq 0 ]; then
    echo "xcat: verification not supported for backend '$DETECTED_BACKEND'." >&2
    return 0
  fi

  echo "â”€â”€â”€â”€ clipboard (verify) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  if ! "${CLIP_READ_CMD[@]}" 2>/dev/null | head -n 10; then
    echo "(failed to read from clipboard)" >&2
  fi
  echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
}

describe_range() {
  local desc=""
  if [ -n "${start_line:-}" ] && [ -n "${end_line:-}" ]; then
    desc="lines ${start_line}-${end_line}"
  elif [ -n "${start_line:-}" ]; then
    desc="lines ${start_line}-end"
  elif [ -n "${end_line:-}" ]; then
    desc="lines 1-${end_line}"
  else
    desc=""
  fi
  echo "$desc"
}

# --- option parsing --------------------------------------------------------

while getopts ":s:e:L:hqvpV-:" opt; do
  case "$opt" in
    s) start_line="$OPTARG" ;;
    e) end_line="$OPTARG" ;;
    L)
      IFS=':' read -r LHS RHS <<<"$OPTARG"
      [ -n "${LHS:-}" ] && start_line="$LHS"
      [ -n "${RHS:-}" ] && end_line="$RHS"
      ;;
    h) usage; exit 0 ;;
    q) QUIET=1 ;;
    v) VERBOSE=1 ;;
    p) PREVIEW=1 ;;
    V) VERSION_ONLY=1 ;;
    -)
      case "$OPTARG" in
        help) usage; exit 0 ;;
        preview) PREVIEW=1 ;;
        quiet) QUIET=1 ;;
        verbose) VERBOSE=1 ;;
        version) VERSION_ONLY=1 ;;
        verify) VERIFY=1 ;;
        compress) COMPRESS=1 ;;
        tee) TEE_MODE=1 ;;
        backend=*)
          BACKEND_OVERRIDE="${OPTARG#backend=}"
          ;;
        types=*)
          normalize_types "${OPTARG#types=}"
          ;;
        list-backends)
          LIST_BACKENDS_ONLY=1
          ;;
        *)
          echo "xcat: unknown option -- --$OPTARG" >&2
          usage
          exit 2
          ;;
      esac
      ;;
    \?)
      echo "xcat: invalid option -- -$OPTARG" >&2
      usage
      exit 2
      ;;
    :)
      echo "xcat: option -$OPTARG requires an argument" >&2
      usage
      exit 2
      ;;
  esac
done
shift $((OPTIND-1))

# Handle simple modes
if [ "$VERSION_ONLY" -eq 1 ]; then
  version
  exit 0
fi

if [ "$LIST_BACKENDS_ONLY" -eq 1 ]; then
  list_backends
  exit 0
fi

# Validate numeric inputs if present
if [ -n "$start_line" ] && ! is_uint "$start_line"; then
  echo "xcat: START must be a positive integer." >&2; exit 2
fi
if [ -n "$end_line" ] && ! is_uint "$end_line"; then
  echo "xcat: END must be a positive integer." >&2; exit 2
fi
if [ -n "$start_line" ] && [ -n "$end_line" ] && [ "$end_line" -lt "$start_line" ]; then
  echo "xcat: END ($end_line) is less than START ($start_line)." >&2; exit 2
fi

# --- main ------------------------------------------------------------------

if ! resolve_clip_cmd; then
  cat >&2 <<'EOF'
xcat: could not find or install a compatible clipboard tool.
Tried: xclip (X11), wl-copy (Wayland), pbcopy (macOS), clip.exe (WSL).
Please install one of them and re-run.
  - Debian/Ubuntu:  sudo apt-get install xclip    # or wl-clipboard on Wayland
  - Fedora:         sudo dnf install xclip
  - Arch:           sudo pacman -S xclip
  - openSUSE:       sudo zypper install xclip
  - Wayland (any):  sudo apt-get install wl-clipboard
EOF
  exit 1
fi

[ "$VERBOSE" -eq 1 ] && [ "$QUIET" -eq 0 ] && echo "xcat: using backend: $DETECTED_BACKEND" >&2

RAW_FILE=$(mktemp "${TMPDIR:-/tmp}/xcat.raw.XXXXXX")
PAYLOAD_FILE=$(mktemp "${TMPDIR:-/tmp}/xcat.payload.XXXXXX")
trap 'rm -f "$RAW_FILE" "$PAYLOAD_FILE"' EXIT

if [ $# -eq 0 ]; then
  INPUT_KIND="stdin"
  INPUT_SOURCE=""

  # stdin â†’ RAW
  cat > "$RAW_FILE"

  if ! is_text_file "$RAW_FILE"; then
    echo "xcat: refusing to operate on non-text stdin." >&2
    exit 1
  fi
else
  path="$1"
  INPUT_SOURCE="$path"

  if [ -d "$path" ]; then
    INPUT_KIND="dir"
    if ! dir_to_stream "$path" > "$RAW_FILE"; then
      exit 1
    fi
  else
    INPUT_KIND="file"
    if [ ! -f "$path" ]; then
      echo "xcat: file not found: $path" >&2
      exit 1
    fi
    if ! is_text_file "$path"; then
      echo "xcat: refusing to operate on non-text file: $path" >&2
      exit 1
    fi
    cat -- "$path" > "$RAW_FILE"
  fi
fi

# Apply line-range filter (if any)
if [ -n "$start_line" ] || [ -n "$end_line" ]; then
  local_start="${start_line:-1}"
  local_end="${end_line:-\$}"
  sed -n "${local_start},${local_end}p" "$RAW_FILE" > "$PAYLOAD_FILE"
else
  cp "$RAW_FILE" "$PAYLOAD_FILE"
fi

RANGE_DESC=$(describe_range)

# Count total lines in the (uncompressed) payload
if have wc; then
  LINES_COPIED=$(wc -l < "$PAYLOAD_FILE" | awk '{print $1}')
fi

COMPRESSED_NOTE=""
if [ "$COMPRESS" -eq 1 ]; then
  COMP_FILE=$(mktemp "${TMPDIR:-/tmp}/xcat.comp.XXXXXX")
  gzip -c "$PAYLOAD_FILE" | base64 > "$COMP_FILE"
  mv "$COMP_FILE" "$PAYLOAD_FILE"
  COMPRESSED_NOTE=" (gzip+base64 encoded)"
fi

# Compute checksum (SHA1 of final payload)
SHA=""
if have sha1sum; then
  SHA=$(sha1sum "$PAYLOAD_FILE" | awk '{print $1}')
elif have shasum; then
  SHA=$(shasum -a 1 "$PAYLOAD_FILE" | awk '{print $1}')
fi

# Clipboard + optional tee
if [ "$TEE_MODE" -eq 1 ]; then
  # Print to stdout and copy in parallel
  cat "$PAYLOAD_FILE" | tee >( "${CLIP_CMD[@]}" >/dev/null ) >/dev/null
else
  cat "$PAYLOAD_FILE" | "${CLIP_CMD[@]}" >/dev/null
fi

# Preview (from payload, i.e., after line-range & compression decisions)
if [ "$PREVIEW" -eq 1 ]; then
  # If compressed, preview the *decompressed* content if possible
  if [ "$COMPRESS" -eq 1 ]; then
    TMP_PREVIEW=$(mktemp "${TMPDIR:-/tmp}/xcat.prev.XXXXXX")
    if base64 -d "$PAYLOAD_FILE" 2>/dev/null | gunzip 2>/dev/null > "$TMP_PREVIEW"; then
      preview_payload "$TMP_PREVIEW"
      rm -f "$TMP_PREVIEW"
    else
      # Fallback: show encoded payload
      preview_payload "$PAYLOAD_FILE"
    fi
  else
    preview_payload "$PAYLOAD_FILE"
  fi
fi

# Verify clipboard contents (if supported)
verify_clipboard

# Final status line
if [ "$QUIET" -eq 0 ]; then
  case "$INPUT_KIND" in
    stdin) what="stdin" ;;
    file)  what="file '$INPUT_SOURCE'" ;;
    dir)   what="directory '$INPUT_SOURCE'" ;;
    *)     what="input" ;;
  esac

  msg="ðŸ“‹ Copied ${what}${COMPRESSED_NOTE}"

  if [ -n "$LINES_COPIED" ]; then
    msg="${msg} (${LINES_COPIED} lines"
    if [ -n "$RANGE_DESC" ]; then
      msg="${msg}, ${RANGE_DESC}"
    fi
    msg="${msg})"
  elif [ -n "$RANGE_DESC" ]; then
    msg="${msg} (${RANGE_DESC})"
  fi

  [ -n "$SHA" ] && msg="${msg} [sha1:${SHA}]"
  echo "$msg."
fi

